sort1 uses: bubble sort

How do you know?:   sort1 took 6.83s to sort random50000.txt; sort1 needs 1.95s to sort the sorted50000.txt; sort1 needs 6.00s to sort the reversed50000.txt;
                    sort1 needs 0.14s to sort random5000.txt; sort1 needs 0.03s to sort the sorted5000.txt; sort1 needs 0.09s to sort the reversed5000.txt;
                    sort1 needs 0.22s to sort random10000.txt; sort1 needs 0.09s to sort the sorted10000.txt; sort1 needs 0.25s to sort the reversed10000.txt;
                    if the condition is best case then this program takes short time than the worst case. so it is Bubble sort.

sort2 uses: merge sort

How do you know?:   sort2 needs 0.75s to sort random50000.txt; sort2 needs 0.85s to sort the sorted50000.txt; sort2 needs 1.90s to sort the reversed50000.txt;
                    sort2 needs 0.03s to sort random5000.txt; sort2 needs 0.11s to sort the sorted5000.txt; sort2 needs 0.03s to sort the reversed5000.txt;
                    sort2 needs 0.08s to sort random10000.txt; sort2 needs 0.08s to sort the sorted10000.txt; sort2 needs 0.07s to sort the reversed10000.txt;
                    all the time values are very close for the n number of data i.e. n log(n) steps for both worst case and best case. So, the program is merge sort.

sort3 uses: selection sort

How do you know?:   sort3 needs 3.08s to sort random50000.txt; sort3 needs 4.02s to sort the sorted50000.txt; sort3 needs 3.90s to sort the reversed50000.txt;
                    sort3 needs 0.08s to sort random5000.txt; sort3 needs 0.08s to sort the sorted5000.txt; sort3 needs 0.06s to sort the reversed5000.txt;
                    sort3 needs 0.14s to sort random10000.txt; sort3 needs 0.26s to sort the sorted10000.txt; sort3 needs 0.17s to sort the reversed10000.txt;
                    this program performs the each and every task even if its not needed. and takes the same steps for both worst case and best case. and requires
                    longest time, so the program is Linear sort
